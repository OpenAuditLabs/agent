"""
Vulnerability patterns and fixes database for OpenAudit Agent
"""

from typing import Dict, List, Optional

VULNERABILITY_PATTERNS = {
    "SWC-107": {
        "name": "Reentrancy",
        "description": """
        Reentrancy occurs when external contract calls are allowed to make new calls back to the calling contract before the first execution is finished. 
        This may cause the different invocations of the function to interact in destructive ways.
        """,
        "impact": "Critical - Can lead to unauthorized withdrawals, drain of contract funds, and manipulation of contract state",
        "detection_tips": [
            "Look for external calls using .call()",
            "Check if state changes happen after external calls",
            "Watch for multiple calls to the same function"
        ],
        "fixes": [
            {
                "pattern": "Checks-Effects-Interactions Pattern",
                "description": "Update state before making external calls",
                "code_example": '''
                // VULNERABLE
                function withdraw(uint _amount) {
                    require(balances[msg.sender] >= _amount);
                    (bool success, ) = msg.sender.call{value: _amount}("");
                    require(success);
                    balances[msg.sender] -= _amount;
                }

                // FIXED
                function withdraw(uint _amount) {
                    require(balances[msg.sender] >= _amount);
                    balances[msg.sender] -= _amount;
                    (bool success, ) = msg.sender.call{value: _amount}("");
                    require(success);
                }
                '''
            },
            {
                "pattern": "ReentrancyGuard",
                "description": "Use OpenZeppelin's ReentrancyGuard or implement a mutex",
                "code_example": '''
                contract SecureContract is ReentrancyGuard {
                    function withdraw(uint _amount) nonReentrant {
                        require(balances[msg.sender] >= _amount);
                        balances[msg.sender] -= _amount;
                        (bool success, ) = msg.sender.call{value: _amount}("");
                        require(success);
                    }
                }
                '''
            }
        ]
    },
    "SWC-101": {
        "name": "Integer Overflow and Underflow",
        "description": """
        Integer overflow/underflow occurs when an arithmetic operation reaches the maximum or minimum size of the integer type.
        For example, a uint8 can only hold values from 0 to 255. Adding 1 to 255 will result in 0.
        """,
        "impact": "High - Can lead to incorrect calculations, token balance manipulation",
        "fixes": [
            {
                "pattern": "SafeMath Usage",
                "description": "Use OpenZeppelin's SafeMath library for Solidity < 0.8.0",
                "code_example": '''
                using SafeMath for uint256;
                
                function transfer(address recipient, uint256 amount) {
                    balances[msg.sender] = balances[msg.sender].sub(amount);
                    balances[recipient] = balances[recipient].add(amount);
                }
                '''
            },
            {
                "pattern": "Solidity 0.8+ Built-in Checks",
                "description": "Use Solidity 0.8.0 or later which includes built-in overflow checks",
                "code_example": '''
                // SPDX-License-Identifier: MIT
                pragma solidity ^0.8.0;
                
                contract SafeContract {
                    function add(uint256 a, uint256 b) public pure returns (uint256) {
                        return a + b; // Will revert on overflow
                    }
                }
                '''
            }
        ]
    },
    "SWC-116": {
        "name": "Block Timestamp Manipulation",
        "description": """
        Block timestamps can be manipulated by miners within certain bounds. Any logic that relies
        directly on block.timestamp for critical decisions can potentially be manipulated.
        """,
        "impact": "Medium - Can affect time-dependent logic like locks and random number generation",
        "fixes": [
            {
                "pattern": "Block Number Usage",
                "description": "Use block.number instead of block.timestamp when possible",
                "code_example": '''
                // VULNERABLE
                if (block.timestamp >= endTime) { ... }
                
                // FIXED
                // Assuming ~15 sec block time
                if (block.number >= endBlock) { ... }
                '''
            },
            {
                "pattern": "Time Delay Buffer",
                "description": "Add buffer time to timestamp checks",
                "code_example": '''
                // Add safety margin
                uint256 constant BUFFER_TIME = 900; // 15 minutes
                
                function isExpired(uint256 deadline) public view returns (bool) {
                    return block.timestamp >= (deadline + BUFFER_TIME);
                }
                '''
            }
        ]
    }
}

def get_vulnerability_info(swc_id: str) -> Optional[Dict]:
    """
    Get detailed information about a vulnerability by its SWC ID.
    
    Args:
        swc_id: The SWC ID of the vulnerability (e.g., "SWC-107")
        
    Returns:
        Dictionary containing vulnerability information and fixes
    """
    return VULNERABILITY_PATTERNS.get(swc_id)

def get_fix_suggestions(swc_id: str) -> List[Dict]:
    """
    Get suggested fixes for a vulnerability.
    
    Args:
        swc_id: The SWC ID of the vulnerability
        
    Returns:
        List of suggested fixes with code examples
    """
    vuln_info = VULNERABILITY_PATTERNS.get(swc_id)
    if vuln_info:
        return vuln_info.get("fixes", [])
    return []

def get_detection_tips(swc_id: str) -> List[str]:
    """
    Get detection tips for a vulnerability.
    
    Args:
        swc_id: The SWC ID of the vulnerability
        
    Returns:
        List of tips for detecting the vulnerability
    """
    vuln_info = VULNERABILITY_PATTERNS.get(swc_id)
    if vuln_info:
        return vuln_info.get("detection_tips", [])
    return []
